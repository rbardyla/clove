// asset_pipeline.h - Complete Asset Pipeline for Handmade Engine
// Zero dependencies, production-grade, cache-friendly design
// Author: Senior Engine Developer
// Date: September 2025

#ifndef ASSET_PIPELINE_H
#define ASSET_PIPELINE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// Forward declarations from your existing systems
typedef struct arena_allocator arena_allocator;
typedef struct hash_map hash_map;

// Asset type enumeration - extensible for new formats
typedef enum asset_type {
    ASSET_TYPE_UNKNOWN = 0,
    ASSET_TYPE_TEXTURE,
    ASSET_TYPE_MODEL,
    ASSET_TYPE_SHADER,
    ASSET_TYPE_AUDIO,
    ASSET_TYPE_FONT,
    ASSET_TYPE_SCENE,
    ASSET_TYPE_MATERIAL,
    ASSET_TYPE_ANIMATION,
    ASSET_TYPE_SCRIPT,
    ASSET_TYPE_PREFAB,
    ASSET_TYPE_CONFIG,
    ASSET_TYPE_COUNT
} asset_type;

// Asset state for hot-reload and streaming
typedef enum asset_state {
    ASSET_STATE_UNLOADED = 0,
    ASSET_STATE_LOADING,
    ASSET_STATE_LOADED,
    ASSET_STATE_FAILED,
    ASSET_STATE_RELOADING,
    ASSET_STATE_QUEUED_RELOAD
} asset_state;

// UUID for asset identification (128-bit)
typedef struct asset_uuid {
    uint64_t high;
    uint64_t low;
} asset_uuid;

// Asset metadata - stored in asset database
typedef struct asset_metadata {
    asset_uuid uuid;
    asset_type type;
    asset_state state;
    
    char source_path[256];      // Original file path
    char cache_path[256];       // Compiled asset path
    
    uint64_t source_timestamp;  // For hot-reload detection
    uint64_t cache_timestamp;   // Compiled asset time
    uint32_t source_hash;       // Content hash for change detection
    
    uint32_t ref_count;         // Reference counting
    uint32_t version;           // Asset version number
    
    // Memory info
    size_t memory_size;         // Size in memory
    void* memory_ptr;           // Pointer to loaded data
    
    // Dependencies
    asset_uuid* dependencies;   // Array of dependent assets
    uint32_t dependency_count;
    
    // Import settings (type-specific)
    void* import_settings;
    size_t settings_size;
} asset_metadata;

// Asset handle for runtime use
typedef struct asset_handle {
    asset_uuid uuid;
    uint32_t generation;        // Handle validation
    void* data;                 // Direct pointer for fast access
} asset_handle;

// Import settings for different asset types
typedef struct texture_import_settings {
    uint32_t max_width;
    uint32_t max_height;
    bool generate_mipmaps;
    bool compress;
    uint32_t compression_quality;
    bool srgb;
} texture_import_settings;

typedef struct model_import_settings {
    float scale;
    bool generate_tangents;
    bool optimize_mesh;
    bool merge_meshes;
    uint32_t max_vertices;
    uint32_t max_bones;
} model_import_settings;

typedef struct audio_import_settings {
    uint32_t sample_rate;
    uint32_t channels;
    uint32_t bit_depth;
    bool compress;
    float compression_ratio;
} audio_import_settings;

// File watcher for hot-reload
typedef struct file_watcher {
    int inotify_fd;             // Linux inotify
    int* watch_descriptors;    // Per-directory watches
    uint32_t watch_count;
    uint32_t watch_capacity;
    
    // Platform-specific data
    #ifdef _WIN32
    void* directory_handles[64];
    void* completion_port;
    #endif
} file_watcher;

// Asset importer interface
typedef struct asset_importer {
    const char* name;
    const char** extensions;    // File extensions this importer handles
    uint32_t extension_count;
    
    // Function pointers for import pipeline
    bool (*can_import)(const char* path);
    bool (*get_dependencies)(const char* path, asset_uuid** deps, uint32_t* count);
    bool (*import)(const char* source, const char* dest, void* settings);
    size_t (*get_memory_size)(const char* path, void* settings);
    bool (*validate)(const void* data, size_t size);
} asset_importer;

// Asset loader for runtime loading
typedef struct asset_loader {
    asset_type type;
    
    // Function pointers for loading pipeline
    void* (*load)(const char* path, arena_allocator* arena, size_t* out_size);
    void (*unload)(void* data, arena_allocator* arena);
    bool (*hot_reload)(void* old_data, void* new_data, size_t new_size);
    void* (*clone)(void* data, arena_allocator* arena);
} asset_loader;

// Asset cache for compiled assets
typedef struct asset_cache {
    char cache_directory[256];
    uint64_t max_cache_size;
    uint64_t current_cache_size;
    
    // LRU eviction
    asset_uuid* lru_list;
    uint32_t lru_count;
    uint32_t lru_capacity;
    
    // Memory mapped files for zero-copy loading
    struct {
        void* base_address;
        size_t size;
        int fd;
    } mmap_regions[256];
    uint32_t mmap_count;
} asset_cache;

// Main asset database
typedef struct asset_database {
    // Core data structures
    hash_map* uuid_to_metadata;     // UUID -> asset_metadata
    hash_map* path_to_uuid;         // Path -> UUID
    hash_map* type_to_assets;       // Type -> UUID array
    
    // Memory management
    arena_allocator* metadata_arena;
    arena_allocator* asset_arena;
    
    // File monitoring
    file_watcher* watcher;
    
    // Import/export pipeline
    asset_importer* importers[32];
    uint32_t importer_count;
    
    asset_loader* loaders[ASSET_TYPE_COUNT];
    
    // Asset cache
    asset_cache* cache;
    
    // Statistics
    struct {
        uint64_t total_assets;
        uint64_t loaded_assets;
        uint64_t memory_used;
        uint64_t cache_hits;
        uint64_t cache_misses;
        uint64_t hot_reloads;
        uint64_t import_time_ms;
        uint64_t load_time_ms;
    } stats;
    
    // Configuration
    struct {
        bool auto_import;
        bool hot_reload_enabled;
        bool validate_assets;
        uint32_t max_concurrent_loads;
        size_t max_memory_usage;
    } config;
} asset_database;

// Asset request for async loading
typedef struct asset_request {
    asset_uuid uuid;
    void (*callback)(asset_handle handle, void* user_data);
    void* user_data;
    uint32_t priority;
    bool async;
} asset_request;

// Asset job for worker threads
typedef struct asset_job {
    enum {
        JOB_LOAD,
        JOB_UNLOAD,
        JOB_IMPORT,
        JOB_COMPILE,
        JOB_VALIDATE
    } type;
    
    asset_uuid uuid;
    char source_path[256];
    char dest_path[256];
    void* settings;
    
    struct asset_job* next;
} asset_job;

// Asset worker thread pool
typedef struct asset_worker_pool {
    pthread_t* threads;
    uint32_t thread_count;
    
    // Job queue (lock-free MPSC queue)
    _Atomic(asset_job*) job_queue_head;
    asset_job* job_queue_tail;
    
    // Completion queue
    _Atomic(asset_job*) completed_head;
    
    _Atomic bool shutdown;
    sem_t work_semaphore;
} asset_worker_pool;

// ============================================================================
// Public API
// ============================================================================

// Database lifecycle
asset_database* asset_database_create(arena_allocator* arena, const char* project_path);
void asset_database_destroy(asset_database* db);
bool asset_database_scan_directory(asset_database* db, const char* directory, bool recursive);
bool asset_database_save(asset_database* db, const char* path);
bool asset_database_load(asset_database* db, const char* path);

// Asset import/export
asset_uuid asset_import(asset_database* db, const char* source_path, void* settings);
bool asset_reimport(asset_database* db, asset_uuid uuid);
bool asset_export(asset_database* db, asset_uuid uuid, const char* dest_path);
bool asset_compile(asset_database* db, asset_uuid uuid);
bool asset_compile_all(asset_database* db);

// Asset loading
asset_handle asset_load(asset_database* db, asset_uuid uuid);
asset_handle asset_load_async(asset_database* db, asset_uuid uuid, void (*callback)(asset_handle, void*), void* user_data);
void asset_unload(asset_database* db, asset_handle handle);
void asset_add_ref(asset_database* db, asset_handle handle);
void asset_release(asset_database* db, asset_handle handle);

// Asset queries
asset_metadata* asset_get_metadata(asset_database* db, asset_uuid uuid);
asset_uuid asset_find_by_path(asset_database* db, const char* path);
asset_uuid* asset_find_by_type(asset_database* db, asset_type type, uint32_t* count);
bool asset_exists(asset_database* db, asset_uuid uuid);
asset_state asset_get_state(asset_database* db, asset_uuid uuid);

// Asset hot-reload
void asset_enable_hot_reload(asset_database* db, bool enable);
void asset_check_hot_reload(asset_database* db);
bool asset_force_reload(asset_database* db, asset_uuid uuid);

// Asset dependencies
asset_uuid* asset_get_dependencies(asset_database* db, asset_uuid uuid, uint32_t* count);
asset_uuid* asset_get_dependents(asset_database* db, asset_uuid uuid, uint32_t* count);
void asset_rebuild_dependencies(asset_database* db);

// Importer/loader registration
void asset_register_importer(asset_database* db, asset_importer* importer);
void asset_register_loader(asset_database* db, asset_type type, asset_loader* loader);

// UUID utilities
asset_uuid asset_uuid_generate(void);
asset_uuid asset_uuid_from_string(const char* str);
void asset_uuid_to_string(asset_uuid uuid, char* buffer, size_t size);
bool asset_uuid_equal(asset_uuid a, asset_uuid b);
uint64_t asset_uuid_hash(asset_uuid uuid);

// Cache management
void asset_cache_clear(asset_database* db);
void asset_cache_validate(asset_database* db);
size_t asset_cache_get_size(asset_database* db);
void asset_cache_set_max_size(asset_database* db, size_t max_size);

// Statistics
void asset_print_stats(asset_database* db);
void asset_reset_stats(asset_database* db);

// ============================================================================
// Implementation Details (normally in .c file)
// ============================================================================

// Fast UUID generation using xorshift128+
static inline asset_uuid asset_uuid_generate(void) {
    static uint64_t s[2] = { 0x123456789ABCDEF0ULL, 0xFEDCBA9876543210ULL };
    
    uint64_t s1 = s[0];
    const uint64_t s0 = s[1];
    s[0] = s0;
    s1 ^= s1 << 23;
    s1 ^= s1 >> 18;
    s1 ^= s0;
    s1 ^= s0 >> 5;
    s[1] = s1;
    
    asset_uuid uuid;
    uuid.high = s0 + s1;
    uuid.low = s1;
    
    // Add timestamp for uniqueness
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    uuid.low ^= (uint64_t)ts.tv_sec << 32 | ts.tv_nsec;
    
    return uuid;
}

// Fast hash for hash map
static inline uint64_t asset_uuid_hash(asset_uuid uuid) {
    // FNV-1a hash
    uint64_t hash = 0xcbf29ce484222325ULL;
    hash ^= uuid.high;
    hash *= 0x100000001b3ULL;
    hash ^= uuid.low;
    hash *= 0x100000001b3ULL;
    return hash;
}

// Check if two UUIDs are equal
static inline bool asset_uuid_equal(asset_uuid a, asset_uuid b) {
    return a.high == b.high && a.low == b.low;
}

// Platform-specific file watching (Linux implementation)
#ifdef __linux__
#include <sys/inotify.h>
#include <unistd.h>

static bool file_watcher_add_directory(file_watcher* watcher, const char* path) {
    int wd = inotify_add_watch(watcher->inotify_fd, path,
                                IN_MODIFY | IN_CREATE | IN_DELETE | IN_MOVED_FROM | IN_MOVED_TO);
    if (wd == -1) return false;
    
    if (watcher->watch_count >= watcher->watch_capacity) {
        watcher->watch_capacity *= 2;
        watcher->watch_descriptors = realloc(watcher->watch_descriptors,
                                            watcher->watch_capacity * sizeof(int));
    }
    
    watcher->watch_descriptors[watcher->watch_count++] = wd;
    return true;
}

static void file_watcher_poll(file_watcher* watcher, void (*callback)(const char* path, uint32_t event)) {
    char buffer[4096] __attribute__((aligned(8)));
    
    while (true) {
        ssize_t len = read(watcher->inotify_fd, buffer, sizeof(buffer));
        if (len <= 0) break;
        
        char* ptr = buffer;
        while (ptr < buffer + len) {
            struct inotify_event* event = (struct inotify_event*)ptr;
            if (event->len > 0) {
                callback(event->name, event->mask);
            }
            ptr += sizeof(struct inotify_event) + event->len;
        }
    }
}
#endif

// Lock-free job queue operations
static void job_queue_push(asset_worker_pool* pool, asset_job* job) {
    job->next = NULL;
    asset_job* prev_head = __atomic_exchange_n(&pool->job_queue_head, job, __ATOMIC_ACQ_REL);
    if (prev_head) {
        prev_head->next = job;
    }
    sem_post(&pool->work_semaphore);
}

static asset_job* job_queue_pop(asset_worker_pool* pool) {
    sem_wait(&pool->work_semaphore);
    
    asset_job* job = __atomic_load_n(&pool->job_queue_head, __ATOMIC_ACQUIRE);
    if (job) {
        asset_job* next = job->next;
        __atomic_store_n(&pool->job_queue_head, next, __ATOMIC_RELEASE);
    }
    
    return job;
}

// Worker thread function
static void* asset_worker_thread(void* arg) {
    asset_worker_pool* pool = (asset_worker_pool*)arg;
    
    while (!__atomic_load_n(&pool->shutdown, __ATOMIC_ACQUIRE)) {
        asset_job* job = job_queue_pop(pool);
        if (!job) continue;
        
        // Process job based on type
        switch (job->type) {
            case JOB_LOAD:
                // Load asset from disk
                break;
            case JOB_IMPORT:
                // Import and process asset
                break;
            case JOB_COMPILE:
                // Compile to optimized format
                break;
            case JOB_VALIDATE:
                // Validate asset integrity
                break;
            case JOB_UNLOAD:
                // Unload from memory
                break;
        }
        
        // Push to completion queue
        asset_job* prev_head = __atomic_exchange_n(&pool->completed_head, job, __ATOMIC_ACQ_REL);
        job->next = prev_head;
    }
    
    return NULL;
}

#endif // ASSET_PIPELINE_H